# 数据查询页面问题修复总结

## 问题描述

用户反映在数据查询页面中，选择已保存查询后点击执行查询能正常工作，但从可用表格/视图中选择表来查询时会出现"Bad Request"错误。

## 问题分析

### 根本原因

1. **数据初始化状态不同**：
   - 已保存查询：加载时会完整设置所有查询状态（表、列、条件等）
   - 表格选择：只设置了表信息，列信息需要异步加载

2. **异步数据加载时机问题**：
   - `fetchTableColumns`函数是异步执行的
   - `executeQuery`可能在列信息完全加载前被触发
   - 导致发送给后端的数据不完整

3. **数据验证不足**：
   - 前端缺少对数据完整性的验证
   - 后端对空或无效数据的处理不够友好

## 修复方案

### 1. 改进表格选择流程

```javascript
// 修改 handleTableSelect 函数
function handleTableSelect(e) {
    // 确保列信息加载完成后再启用查询功能
    fetchTableColumns(tableName).then(() => {
        // 自动添加主要列避免空列情况
        if (selectedTables.length === 1 && selectedColumns.length === 0) {
            // 自动选择前10个列
        }
        updateColumnsDropdown(tableName);
        enableQueryControls();
        updateSqlPreview();
    }).catch(error => {
        console.error("获取列信息失败:", error);
        alert('获取表格列信息失败，请重试');
    });
}
```

### 2. 增强查询执行验证

```javascript
function executeQuery() {
    // 验证数据完整性
    const missingColumns = selectedTables.filter(table => !allTableColumns[table]);
    if (missingColumns.length > 0) {
        // 尝试加载缺失的列信息
        Promise.all(missingColumns.map(table => fetchTableColumns(table)))
            .then(() => executeQuery()) // 重新执行查询
            .catch(error => ToastNotification.error('加载表结构信息失败'));
        return;
    }
    
    // 数据格式验证和清理
    const processedColumns = selectedColumns.map(col => {
        if (typeof col === 'object' && col !== null) {
            return col.fullName || col.FullName || `${col.tableName}.${col.columnName}`;
        }
        return String(col);
    }).filter(col => col && col.trim() !== '');
}
```

### 3. 后端数据验证增强

```csharp
[HttpPost]
public async Task<IActionResult> ExecuteQuery([FromBody] QueryViewModel query)
{
    // 基本数据验证
    if (query == null)
        return BadRequest(new { error = "查询数据不能为空" });
    
    if (query.Tables == null || query.Tables.Count == 0)
        return BadRequest(new { error = "请选择至少一个表进行查询" });
    
    // 初始化空列表以避免null引用
    query.Columns = query.Columns ?? new List<string>();
    query.JoinConditions = query.JoinConditions ?? new List<string>();
    query.WhereConditions = query.WhereConditions ?? new List<string>();
    query.OrderBy = query.OrderBy ?? new List<string>();
    query.Parameters = query.Parameters ?? new Dictionary<string, object>();
}
```

### 4. 改进错误处理和用户反馈

```javascript
// 增强的错误处理
error: function(xhr, status, error) {
    // 根据HTTP状态码提供友好的错误信息
    if (xhr.status === 400) {
        errorMsg = '请求数据格式错误：' + errorMsg;
        // 提供调试建议
        console.log('调试建议：检查表、列、条件格式');
    } else if (xhr.status === 500) {
        errorMsg = '服务器内部错误：' + errorMsg;
    }
    
    ToastNotification.error(errorMsg, 8000);
}
```

### 5. 列信息加载优化

```javascript
function fetchTableColumns(tableName) {
    return new Promise((resolve, reject) => {
        $.ajax({
            url: `/QueryBuilder/GetColumns?tableName=${encodeURIComponent(tableName)}`,
            method: 'GET',
            timeout: 10000, // 10秒超时
            success: function(columns) {
                // 验证返回的列数据
                if (!columns || !Array.isArray(columns) || columns.length === 0) {
                    ToastNotification.warning(`表 ${tableName} 没有可用的列信息`);
                    allTableColumns[tableName] = [];
                } else {
                    allTableColumns[tableName] = columns;
                    ToastNotification.success(`成功加载表 ${tableName} 的 ${columns.length} 个列`);
                }
                resolve(allTableColumns[tableName]);
            }
        });
    });
}
```

## 改进效果

### 用户体验提升

1. **自动列选择**：选择表后自动添加主要列，避免空查询
2. **加载状态提示**：显示列信息加载进度和状态
3. **友好错误提示**：根据错误类型提供具体的解决建议
4. **数据验证**：防止无效查询请求发送到后端

### 技术改进

1. **异步流程优化**：确保数据完整性后再执行查询
2. **错误处理增强**：提供详细的调试信息和用户指导
3. **数据验证**：前后端双重验证确保数据完整性
4. **性能优化**：缓存列信息，避免重复请求

## 测试建议

1. **表格选择测试**：
   - 选择单个表并立即执行查询
   - 选择多个表执行查询
   - 在列信息加载过程中尝试执行查询

2. **错误场景测试**：
   - 网络断开时执行查询
   - 选择不存在的表
   - 权限不足的情况

3. **对比测试**：
   - 已保存查询执行
   - 表格选择查询执行
   - 确保两种方式行为一致

通过这些改进，现在从表格选择和已保存查询两种方式应该都能正常工作，用户体验也得到了显著提升。
